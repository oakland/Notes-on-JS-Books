<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>22.3.1_advancedTimers</title>
	<script type="text/javascript">
		//使用 setTimeout() 或者 setInterval() 创建的定时器可以实现一些有趣而有用的函数。尽管，普遍的误解认为 JS 的计时器就是实际的线程，JS 实际上只运行在单线程的环境中。那么，定时器仅仅是用于安排未来某个时间点代码执行的发生。执行的时间不能保证，因为其他的代码在整个页面生命周期中会在不同的时间控制 JS 的进程(process)。当页面下载时代码的运行，事件处理器，以及 Ajax 回调函数运行时都必须使用同一个线程(use the same thread for execution)。排列好哪段代码在什么时间具有优先权是浏览器的工作。
		//将 JS 认为是在时间线上运行的话有助于我们理解。当一个页面载入的时候，首先被执行的代码是包含在 <script> 标签中的代码。这些代码通产是在页面生命周期中未来要被使用的函数和变量的声明，但是有时候也会包含一些初始化的数据进程(data processing)。从这个时间点以后，JS 进程就会等待未来代码的运行。当进程不是很忙碌的时候，要出发的下一段代码会立即被执行。例如，当一个按钮被点击的时候， onclick 事件处理器就会立即执行，只要 JS 进程没有同时在执行其他代码。类似的页面的时间线如下图所示：<advancedTimers1.png>
		//伴随着主要的 JS 执行进程，存在一个下一个进程空闲时候应当被执行的代码队列。随着页面生命周期的前进，代码会按照应当被执行的顺序逐渐的添加到队列中。例如，当按钮被点击的时候，时间处理器函数代码就会被添加到队列中，在下次可能的时候就会被执行。当一个 Ajax 响应被获取的时候，回调函数的代码会被添加到队列中。JS 中没有什么代码会被立即执行；只有当进程闲置的时候才会被执行。
		//定时器通过固定一段时间之后插入代码的方式与队列一起工作。注意，添加队列到代码中并不意味着代码会被立即执行；这只表示代码会被尽快的执行。设置一个 150ms 的定时器执行事件并不意味着代码会在 150ms 之后执行；这只以为这代码会在 150ms 之后被添加到执行队列中。如果那个时间点恰好队列中没有任何其他的事件，定时器代码就会被执行，让我们仿佛觉得代码是按照我们指定的时间执行的。而另外一些时候，代码可能会要耗费更长的时间去执行。
		//考虑如下例子：
		var btn = document.getElementById('my-btn');
		btn.onclick = function() {
			setTimeout(function() {
				document.getElementById('message').style.visibility = "visible";
			}, 250);
			//other code
		};
		//这里，按钮设置了一个事件处理器函数。事件处理器设置了一个 250ms 的定时器。当按钮被点击的时候，onclick 事件处理器首先被添加到队列中。当被执行的时候，定时器就被设置好了，250ms 之后，这段具体的代码就会被添加到执行队列中。效果就是，setTimeout() 的调用表示一些代码会延迟执行。
		//关于定时器最重要的一件事情就是，具体的间隔的是定时器代码会何时被添加到队列中，而不是代码实际上什么时候会执行。如果上例中 onclick 事件处理器要在 300ms 后执行，那么事件处理器代码，最早会定时器设置后的 300ms 时执行。所有在执行队列中的代码都必须等待 JS 进程空闲的时候才可以被执行，不论代码是以何种方式被添加到队列中的，请看 <advancedTimers2.png>：
		//从上图我们可以看出，尽管定时器代码(timer code)在 255ms 标记的位置就已经被添加到了队列中，它在那个时候依然不能被执行，因为 onclick 事件处理器依然在运行。定时器代码可以执行的第一时间点就是 300ms 的标记处，即 onclick 事件处理器函数结束的位置。
		//FF 定时器的实现可以允许你决定定时器可以向后拖延多久。它通过在要执行的定时器和间隔之间传入一个微分的方式来实现。如下例：

		//works in FF only
		setTimeout(function() {
			if (diff > 0) {
				//call is later
			} else if (diff < 0) {
				//call is early
			} else {
				//call is on time
			}
		}, 250)
		// 当一段代码的执行结束之后，JS 进程会退让(yield)很短的一段时间，以便于页面中的其他进程可以被执行。鉴于 JS 可以阻止页面中的其他进程，这些短暂的空隙是非常有必要的，可以阻止用户 locking(locking 在长运行代码中也会发生)。设置一个计时器可以保证，在计时器代码执行之前至少有一次进程中断(process break)。
	</script>
</head>
<body>
	<img src="advancedTimers1.png" alt="">
	<img src="advancedTimers2.png" alt="">
</body>
</html>